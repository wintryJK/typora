# day5

## 内容回顾

### 自定义类型和类型别名

```go
type MyInt int // 自定义类型
type newInt int // 类型别名
```

类型别名只在代码编写过程中有效，编译完之后不存在，内置的`byte`和`rune`都属于类型别名，编写过程中易于理解

### 结构体

​	基本的结构类型----->有局限性

```go
var name = "jkk"
```

​	结构体是自己造的可以保存多个维度的数据

```go
type person struct{
	name string
    age int
    id int64
    addr string
}
```

### 匿名结构体

​	多用于临时场景

```go
var a struct{
    x int
}
```

### 结构体初始化

### 构造函数



### 方法和接收者

​	方法是有接收者的函数，接收者是指哪个类型的变量可以调用

​	结构体是值类型（里面的值类型，修改时接收者要设置成指针，引用类型不需要）

### 结构体嵌套

​	名称   类型   // 嵌套别的结构体

### 结构体匿名字段

​	匿名嵌套别的结构体，使用类型名做名称

### json序列化与反序列化

经常出现的问题：

1. 结构体内部的首字母要大写！！不大些别的包访问不到
2. 反序列化时要传递指针，传值无法反序列化



## 今日内容

### 接口（interface）

`接口是一种类型，是一种特殊的类型，它规定了变量有哪些方法`

在编程中会遇到以下场景:

​	不关心变量类型，只关心能调用什么方法

#### 接口的定义

```go
type 接口名 interface {
    方法名1(参数1，参数2，...)(返回值1，返回值2，...)
    方法名2(参数1，参数2，...)(返回值1，返回值2，...)
}
```

#### 接口的使用

用来给变量\参数\返回值等设置类型

#### 接口的实现

一个变量如果实现了接口中规定的所有的方法，那么这个变量就实现了这个接口，可以成为这个接口类型的变量

这样就实现了接口变量能够存储不同的值

- 动态类型  --> nil
- 动态值      --> nil

![image-20210331112941806](C:\Users\wintryJK\Desktop\workspace\Typora-workspace\Go语言\day5.assets\image-20210331112941806.png)

#### 使用值接收者和指针接收者实现接口的区别

`使用值接收者实现接口，结构体类型和结构体指针类型的变量都能存`

`指针接收者实现接口只能存结构体指针类型的变量`

#### 接口和类型的关系

多个类型可以实现同一个接口

一个类型可以实现多个接口

#### 空接口

没有必要起名字，通常定义成下面的格式

```go
interface{} // 空接口
```

典型的是Println，可以接收任意类型，可以使用空接口实现

```go
func Println(a ...interface{}) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}
```

所有类型都实现了空接口，也就是任意类型的变量都能保存到空接口中

#### 类型断言

像知道空接口中接收的值具体是什么

### 包（package）

#### 包的路径

- 从`GOPATH/src`后面的路径开始写起，一直到文件夹名
- 路径分隔符用`/`windows和linux都是
- 想被别的包调用首字母大写
- 单行和多行导入
- 导入包的时候可以指定别名
- 导入包不想使用包内部的标识符，需要使用匿名导入
- 每个包导入的时候会自动执行init（）函数，没有参数没有返回值也不能手动调用
- 多个包中都定义init，执行顺序从最初被导入的开始执行

### 文件操作



## 作业

写日志库

接口：日志可以输出到终端，也可以输出到文件，输出到kafka

文件操作

需求：

1. 可以往不同的输出位置记录日志
2. 日志分成五种级别

